<!doctype html><html lang=ja><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1">
<link rel=stylesheet href=/sass/main.min.6e96a703db6986a810b78b787f715c251448097cb1b37a5f2cb675808b29a91d.css>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script defer>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script>
<script defer src=/js/prism.min.js></script>
<link rel=stylesheet href=/css/prism.min.css>
</head>
<body>
<main id=content>
<p class=category>
カテゴリー: <a href=/post>post</a>
</p>
<article class=suuri><p>C 問題についてのみ書きます。</p>
<h1 id=hello-2020-c-new-year-and-permutation>Hello 2020 C New Year and Permutation</h1>
<p><strong>問題</strong></p>
<p>順列$p_1, p_2, &mldr;, p_n$が与えられる。このとき、部分列$[l,r]$であって$max(p_l,..,p_r) - min(p_l,..,p_r) = r - l$が成り立つものを framed segment と呼ぶことにする。すべての長さ$N$の順列に対して、framed segment の数を数え上げてその和を素数$M$で割った値を求めよ。</p>
<p><strong>解法</strong></p>
<p>順列が与えられて、それに対する framed segment の数を数えると$O(N!)$になってしまい計算量的に無理。そこで、<strong>視点を変えて</strong>サイズ$k$の framed segment を横断的に数え上げる方法を考える。<br>
サイズ$k$の framed segment の位置、内部で使われる数の集合(順番は無視する)を考える。</p>
<p><img src=./p-1.png alt=p-1.png></p>
<p>図のように位置はスタート地点が$1$から$n-k+1$で全部で$n-k+1$通りある。<br>
また、内部で使われる数は、$r-l+1$個の相異なる数の最大値と最小値の差が$r-l$であることから、連続した$k$個の数なので、これもスライドして考えると$n-k+1$種類ある。</p>
<p>次に、framed segment 外部と内部の順列を考える。これは、内部で$k!$通り、外部で$(n-k)!$通りである。</p>
<p>$1 \leq k \leq n$よりこれらを足し合わせて$m$で割れば答えが得られる。</p>
<p><strong>実装</strong></p>
<p>最後の足し合わせるところで$O(N)$であるので、$N \leq 250000$から各 framed segment のサイズごとは$O(\log N)$以下の計算量である必要がある。<br>
ここで、factorial は$f(n) = f(n-1) \times n$であることを考えると、これは配列と非常に相性がよく、前計算をしてその配列を使えばよいとわかる。</p>
<pre tabindex=0><code>vector&lt;i64&gt; fact(n+1);
fact[0] = 1;
for(i64 i=1;i&lt;=n;i++)fact[i] = fact[i-1]*i%m;
for (k=1;k&lt;=n;k++){
    res += (サイズkのframed segmentの数)
}
</code></pre><p>注意としては、サイズ k の framed segment の数を求める時の overflow である。一つ掛けるごとに MOD をとらなければ違う答えになってしまった。<br>
計算量は前計算$O(N)$, res に足し合わせて$O(N)$で全体で$O(N)$である。</p>
<p><strong>コード</strong></p>
<p><a href=https://codeforces.com/contest/1284/submission/68567949>https://codeforces.com/contest/1284/submission/68567949</a></p>
<p><strong>感想</strong></p>
<p>はじめは MOD が関わるライブラリゲーだと思って mod_factorial なる関数を作ったが意味なかった。でもまた同じ思考になるかもしれないので、ライブラリのコメント欄に書いておいた。<br>
ModInt 理解したい。</p>
</article>
<footer>
<p class=license>
This document is licensed under
<a href=https://creativecommons.org/licenses/by/4.0/ target=_blank rel="noopener noreferrer">CC-BY-4.0</a>
</p>
<p class=repository>
<a href=https://github.com/uta8a/discussion/discussions/1 target=_blank rel="noopener noreferrer">discussion</a>にコメントする
</p>
</footer>
</main>
</body>
</html>