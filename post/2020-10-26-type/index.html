<!doctype html><html lang=ja><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1">
<link rel=stylesheet href=/sass/main.min.6e96a703db6986a810b78b787f715c251448097cb1b37a5f2cb675808b29a91d.css>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script defer>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script>
<script defer src=/js/prism.min.js></script>
<link rel=stylesheet href=/css/prism.min.css>
</head>
<body>
<main id=content>
<p class=category>
カテゴリー: <a href=/post>post</a>
</p>
<article class=suuri><ul>
<li>また読んでいる途中です。</li>
</ul>
<h2 id=第-1-章>第 1 章</h2>
<ul>
<li>1.1 演習問題がやさしいなと思ったらいっぱい間違えた。「ならば」の使い方が難しい。</li>
<li>2 項関係が直積(感覚的には 組 だと思えば OK)の部分集合を指していることの理解に苦労した。まず、関係とは例として <code>&lt;</code> が考えられるけど、 <code>1&lt;2</code> を見ると 1,2 の間に挟まっているやつなのにこれが集合になる？？？という記号に対する違和感を持った。実際は、 <code>x&lt;y</code> は <code>(x,y)</code> が満たす条件を定めていて、その条件を満たすような <code>(x,y)</code> を集めているのでこれは直積の部分集合になる。</li>
<li>関数もそうだが、今まで習ってきた <code>x&lt;y</code> や <code>f(x)=y</code> という表記に慣れすぎていて、それらを統一的に二項関係 <code>(x,y)∈R</code> という観点からまとめ直すことに苦労した。</li>
<li>対角線論法の理解で、 <code>f(n)(n)</code> の意味を理解するところで苦労した。まず勘違いとして、 <code>f(n)</code> は 0,1 のいずれかだと思っていた。この勘違いのもとでは <code>f(n)</code> は関数ではないので <code>f(n)(n)</code> はおかしいことになる。幸い Twitter でフォローしている方に教えてもらって、 <code>f</code> は Nat -> {0,1}への関数を集めたものなので、 <code>f(n)</code> は(それら関数たちを番号付けできたという仮定をして)、n 番目の関数であるという意味にあたることが理解できた。したがって、 <code>f(n)(n)</code> は「n 番目の関数に引数 n を渡したもので、0 or 1 を返す」という理解になる。こうすれば、 <code>g=f(m)</code> なら <code>(f(m))(m)=0</code> は <code>f(m)(m)=0</code> となることが理解でき、後半のパートも理解できる。</li>
</ul>
<h2 id=第-2-章>第 2 章</h2>
<ul>
<li>2.2 曖昧な構文が存在しないように BNF を構成するところが苦労した。以下のように構成するとうまくいくことが多い気がする</li>
<li>とりあえず下のやつを最初に持ってきて、後ろに書くやつをうまく考える</li>
</ul>
<pre tabindex=0><code>A ::= B | ~
B ::= C | ~
C ::= (A) | ~
</code></pre><ul>
<li>2.3 具象構文と抽象構文の違いについての理解。構文解析を行うと、それは構文として正しい構造を持つことがチェックされているので、このパートで構造チェック(演算子の優先度や、括弧の有無)が走っている。そこで次に意味論パート(構造は合っているが、意味として正しいか？)に移るので、ここでは構造としての正しさを考えなくてよい。したがって、括弧の有無などは抽象構文では気にしなくてよいことになる。</li>
</ul>
</article>
<footer>
<p class=license>
This document is licensed under
<a href=https://creativecommons.org/licenses/by/4.0/ target=_blank rel="noopener noreferrer">CC-BY-4.0</a>
</p>
<p class=repository>
<a href=https://github.com/uta8a/discussion/discussions/1 target=_blank rel="noopener noreferrer">discussion</a>にコメントする
</p>
</footer>
</main>
</body>
</html>